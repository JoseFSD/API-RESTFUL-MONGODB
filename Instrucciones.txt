SIGUE LA SIGUIENTE SECUENCIA DE PASOS PARA ENTENDER EL FLUJO DE CREACIÓN DEL PROYECTO
-------------------------------------------------------------------------------------

1. Nos ubicamos en el path donde queramos trabajar y escribimos el comando: "npm init"

2. Seleccionamos todo YES por defecto manualmente, o escribiendo en lugar de npm init, "npm init --yes"

3. Se acaba de crear nuestro package.json dentro del path de nuestro proyecto

4. Instalamos express y mongoose, para ello introducimos el comando "npm instal express" o abreviado "npm i express".
    Si lo deseamos podemos instalar ambas librerías a la vez "npm i express mongoose"

5. Deberíamos tener en nuestro package.json dentro del objeto "dependencies" algo parecido a lo siguiente: 

    "dependencies": {
        "express": "^4.17.1",
        "mongoose": "^5.13.2"
    }

6. Después de esto deberíamos poder ver nuestra carpeta node_modules con todos los paquetes necesarios para
    comenzar nuestro proyecto

7. Creamos nuestro archivo principal app.js

CREANDO LA ESTRUCTURA BÁSICA DEL PROYECTO
-----------------------------------------

8. Creación de carpetas:
    - Creamos carpeta para trabajar los modelos, de nombre models
    - Creamos carpeta para trabajar las rutas, de nombre routes
    - Creamos carpeta para trabajar los controladores, de nombre controllers
    - Creamos la carpeta config, donde crearemos los archivos para la conexión con la DB

    8.1. Creamos el archivo usuario_model.js y curso_model.js dentro de la carpeta models
    8.2. Creamos el archivo usuarios.js y cursos.js dentro de la carpeta routes
    8.3. Creamos el archivo usuarios_controller.js y cursos_controller.js dentro de la carpeta controllers

9. Comenzamos a configurar nuestro app.js
    - requerimos express y mongoose
    - definimos el puerto de ejecución de nuestro servicio
    - conectamos con la base de datos

CREANDO TODA LA FUNCIONALIDAD DE USUARIOS
-----------------------------------------

10. Creamos los modelos para poder comenzar a crear colecciones (tablas en MySQL) y llenarlas con documentos 
    (también llamados filas o tuplas en MySQL)
        - usuario_model, como este archivo lo vamos a trabajar como modelo basado en un esquema de mongoDB vamos 
        a necesitar utilizar mongoose

11. Creamos nuestro archivo de ruta para usuarios, routes/usuarios_routes.js y aquí configuraremos la ruta y llamaremos 
    al método que queremos que se ejecute desde controller/usuarios_controller.js

12. Creamos los métodos con los tipos de consultas de cada ruta en nuestro controller/usuarios_controller.js

13. Validamos los datos que introduce el usuario, para ello descargamos e instalamos @hapi/joi con el comando 
    "npm i @hapi/joi", esto lo hacemos ya que necesitamos validar nombre, email y contraseña

14. OJO!! recomendación seguir la documentación para revisar todo el potencial de esta librería 
    https://hapi.dev/tutorials/validation/?lang=en_US

15. Por lo general, al principio de nuestro archivo requeriremos Joi tal como indica la documentación, luego configuraremos 
    nuestros validadores y finalmente se utilizarán para validar los datos que recibimos del usuario a través del body, query, params...

CREANDO TODA LA FUNCIONALIDAD DE CURSOS
---------------------------------------

A partir de aquí la secuencia de pasos se repite, en este caso para la creación de Cursos. En este apartado he omitido 
comentarios en el código para que se vea cómo debería quedar un código final, más limpio y ordenado

16. Chequeamos los parámetros que hemos establecido para la creación de cada Cursos

17. Incluimos la ruta en nuestro app.js "localhost:3000/api/cursos"

18. Configuramos las rutas en el archivo routes/cursos_routes.js que serán las mismas que en usuarios_routes.js, ya que 
    queremos poder hacer lo mismo con cursos, es decir: crear, actualizar, borrar, consultar...

19. Creamos los métodos que vamos a utilizar en controllers/cursos_controller.js
    OJO!! en este caso las búsquedas para actualizar o eliminar, se realizarán por el "_id" que asigna de forma automática 
    mongoDB al documento en el momento de la creación del mismo

AÑADIENDO SEGURIDAD A NUESTRO PROYECTO
--------------------------------------

20. Comenzamos este apartado instalando JWT (Json Web Token), bcrypt (para encriptar contraseñas), vamos a proteger los datos del usuario, proteger las rutas, 
    también usaremos middleware de validación, crearemos un login

21. Lo primero que debemos hacer es controlar qué tipo de datos devolvemos en respuestas a la petición http. Para este caso
    revisaremos todos las "response" de los métodos que hemos creado en usuarios_controller.js

22. Instalamos "npm install bcrypt" y seguimos los pasos de la documentación para aprender a usarla e implementar el código en nuestra api
    https://www.npmjs.com/package/bcrypt

23. Validación de usuarios: comprobaremos el email, si es correcto comprobaremos el password y si es correcto, entonces devolveremos el nombre y email del usuario.
    Todo esto para comprobar que estamos verificando un logueo de forma correcta. Para ello crearemos el archivo llamado auth.js y deberemos crear toda una serie de 
    archivos al igual que hicimos con cursos y usuarios. Añadir al app.js, crear el archivo auth_route y crear el archivo auth_controller con el método login

24. Implementación del token. Desde el servidor hasta el cliente. 
    Servicio --> auth, cliente --> Android, IOS, Web

    - El cliente primero envía al servidor su usuario y contraseña para iniciar sesión
    - Una vez validados los datos, nuestro servicio de autenticación genera un token y se lo devuelve al cliente
    - El cliente recibe el token y lo guarda para poder utilizarlo cuando haga peticiones a nuestra apirest (get, post, put, delete)
    - Una vez el servicio recive ese token, devuelve el recurso solicitado validado sin la necesidad de volver a iniciar sesión (este privilegio durará el periodo de tiempo que se haya configurado o hasta que se borre el token del cliente)

25. "npm install jsonwebtoken"
    https://www.npmjs.com/package/jsonwebtoken

26. Antes de devolver los datos a través de la request, deberemos seguir la documentación de JSONWEBTOKEN para crear el token y devolverlo con la request

CONFIGURANDO NUESTRO CONFIG, VARIABLES DE ENTORNO
-------------------------------------------------

27. Para no introducir a fuego el secreto en nuestro código, y que nadie pueda verlo, lo ideal es generar unas variables de entorno, estas variables solo se almacenarán en el 
    servidor. Para ello instalamos "npm i config", y creamos los archivos default.json, development.json y production.json dentro de la carpeta config que habíamos creado vacía 
    al principio.

28. Para indicarle a NODE que estamos trabajando en un entorno de desarrollo y nos coja la configuración del development.json, deberemos introducir el siguiente comando
    antes de arrancar el servicio. 

        - "export NODE_ENV=development" 
    
    y posteriormente arrancamos nuestro servicio 
    
        - "node app.js" / si tienes instalado nodemon entonces sería "nodemon app.js" / o si tienes hecho el *script en el package.json "npm start"

    *script --> para generar un script en el que solo tengas que escribir en consola "npm start" y arranque el servidor tienes que ir al package.json y modificar la siguiente línea
    en función de si tienes instalado nodemon o no:

        Si tienes instalado *nodemon:

            "scripts": {
                "start": "nodemon app.js"
            },

        Si no tienes instalado nodemon:

            "scripts": {
                "start": "node app.js"
            },

CONFIGURANDO NODEMON
--------------------

    *Si no tienes instalado nodemon y quieres hacerlo, "npm i nodemon" y después de instalarlo modificamos el script en el package.json tal como se indica anteriormente

    OJO!! Ahora, con nodemon instalado no tendrás que estar parando y arrancando el servicio, ya que cada vez que guardes un cambio en tus archivos, automáticamente nodemon 
    tirará el servicio y lo volverá a ejecutar

29. Procedemos a proteger las rutas. Utilizamos las cabeceras (con sus keys y sus values)

    Llegado a este punto, si nos vamos a postman o nuestro servicio que consuma el front, y realizamos un get a la ruta de nuestro servicio, 
    en este caso "localhost:3000/api/usuarios" el resultado de esta búsqueda será el listado de todos los usuarios. 
    
    Nosotros no queremos esto, queremos que nos devuelva el resultado para el caso en el que la persona que esté logueada tenga ese permiso. 
    
    Por lo tanto, deberemos enviarle aparte de nuestra petición http de tipo GET el token, generado tras el inicio de sesión. De esta forma desde el lado del servidor podemos, 
    verificar ese token y si es correcto le devolvemos los datos. 
    
    OJO!! el token puede ser correcto y que haya expirado, en cuyo caso no funcionaría, hay que tenerlo en cuenta.

    Así que, desde postman realizaremos un get a la ruta localhost:3000/api/usuarios, además le enviaremos al servidor los siguientes datos a través de la 
    cabecera, Headers (lo encontrarás en el mismo conjunto de pestañas donde podemos ver params o body):
        - en el campo KEY escribiremos Authorization
        - en el campo VALUE escribiremos nuestro token

    Recuerdo que en este punto, al estar utilizando Postman, estamos simulando el lado del cliente, y a través de este Header le pasamos al servicio el token que 
    hemos recibido después de iniciar sesión)

    Ahora sí, trabajaremos en nuestro código para validar ese token antes de devolver en el request el listado de usuarios (para este caso)

30. Para poder proteger nuestras rutas, vamos a crear un middleware para que verifique el acceso antes de ejecutar la petición de la ruta que nosotros queramos proteger.

    Un middleware es un archivo que suele hacer de intermediario, en este caso entre la petición de nuestro cliente y nuestro servicio. El middleware verify (también lo 
    puedes encontrar como auth), contiene un método de la librería jsonwebtoken llamado "verify" (de ahí el mismo nombre al archivo middleware). Este trabaja con 3 
    parámetros (request, response, next), el primero y segundo ya los conocemos, reciben las peticiones y las devuelven al cliente. Next sin embargo, se encarga de 
    indicar a nuestro código, que si el método verify es correcto, continue con la petición.

    Por ejemplo, para una petición get que se encargue de listar todos nuestros usuarios, antes de listar los usuarios pasará por el middleware que verificará si 
    nuestro token es válido. En el caso en que todo esté correcto continuará con la petición get y nos devolverá el listado de usuarios.

31. Creamos nuestra carpeta de nombre "middlewares" y dentro de ella crearemos el archivo "verify.js"

    Consultamos nuevamente la documentación de jsonwebtoken para consultar cómo crearlo https://www.npmjs.com/package/jsonwebtoken

32. Ya creado el archivo, requerimos nuestro middleware verify a nuestros archivos de rutas que queremos proteger y desde dentro, en cada tipo de petición que queramos
    proteger, le pasamos el verify.

    Ejemplo:

    requerimos:
        const verify = require('../middlewares/verify.js);

    incluimos en la rutas que deseamos el verify:
        app.get('localhost:3000/api/usuarios/', verify, users_controller.getAllUsers);

    Como se puede comprobar, en la ruta api/usuarios/, primero le indicamos que debe de ejecutar el verify, y si todo sale bien, ejecutará su función next, que le permitirá poder
    ejecutar users_controller.getAllUsers

